<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="referrer" content="origin">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <title>
        
            ES6-ES12相关
        
    </title>
    <link rel="shortcut icon" href="#"/>

    <link type="text/css" rel="stylesheet" href="/font/LongCang.css">
    <link type="text/css" rel="stylesheet" href="/font/Monda.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSansSC.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSerifSC.css">
    <link type="text/css" rel="stylesheet" href="/font/Playball.css">
    <link type="text/css" rel="stylesheet" href="/font/PTMono.css">
    <link type="text/css" rel="stylesheet" href="/font/Roboto.css">
    <link type="text/css" rel="stylesheet" href="/font/RobotoSlab.css">
    <link type="text/css" rel="stylesheet" href="/font/Rosario.css">
    <link type="text/css" rel="stylesheet" href="/font/UbuntuMono.css">

    <link type="text/css" rel="stylesheet" href="/css/base.css">
    <link type="text/css" rel="stylesheet" href="/css/code.css">

    <script type="text/javascript" src="/js/jquery-3.4.1.min.js"></script>
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
    <a id="cover"></a>
    <link type="text/css" rel="stylesheet" href="/css/post.css">
<div id="header" class="header">
    <div class="vertical">
        <div class="inner">
            
                <h1 class="header-subtitle">ES6-ES12相关</h1>
                <div class="header-subinfo">
                    <p class="article-info-text">
                        <span>
                            <i class="iconfont icon-time"></i> 发表时间：2022-10-21
                        </span>
                        
                            <span id="/2022/10/21/13. 跨域解决办法/" class="leancloud_visitors" data-flag-title="ES6-ES12相关">
                                <i class="iconfont icon-browse"></i> 阅读：<sapn class="leancloud-visitors-count"></span>
                            </span>
                        
                        <span>
                            <i class="iconfont icon-interactive"></i> 评论：<span class="valine-comment-count" data-xid="/2022/10/21/13. 跨域解决办法/"></span>
                        </span>  
                    </p>
                    
                    
                </div>
            
        </div>
    </div>
    
</div>
<div id="container">
    
        <!-- 文章页面 -->
        <div id="article">
            <div class="toc"></div>
            <div class="article-body">
                <h1 id="ES2016-ES7"><a href="#ES2016-ES7" class="headerlink" title="ES2016(ES7)"></a>ES2016(ES7)</h1><h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h2><p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.includes(valueToFind[, fromIndex])</span><br></pre></td></tr></table></figure>

<p><code>valueToFind</code>，需要查找的元素值。</p>
<p><code>fromIndex</code> 可选 从<code>fromIndex</code> 索引处开始查找 <code>valueToFind</code>。如果为负值（即从末尾开始往前跳 <code>fromIndex</code> 的绝对值个索引，然后往后搜寻）。默认为 0。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr = [&#x27;es6&#x27;, &#x27;es7&#x27;, &#x27;es8&#x27;]</span><br><span class="line">console.log(arr.includes(&#x27;es7&#x27;)) // true</span><br><span class="line">console.log(arr.includes(&#x27;es7&#x27;, 1)) // true</span><br><span class="line">console.log(arr.includes(&#x27;es7&#x27;, 2)) // false</span><br><span class="line">console.log(arr.includes(&quot;es7&quot;, -1)); // fsle</span><br><span class="line">console.log(arr.includes(&quot;es7&quot;, -2)); // true</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>使用 <code>includes()</code>查找字符串是区分大小写的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [&quot;es6&quot;, &quot;es7&quot;, &quot;es8&quot;, &quot;a&quot;];</span><br><span class="line">console.log(arr.includes(&quot;A&quot;)); // false</span><br></pre></td></tr></table></figure>

<p>使用 <code>includes()</code>只能判断简单类型的数据，对于复杂类型的数据，比如对象类型的数组，二维数组，这些是无法判断的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [&#x27;es6&#x27;, [&#x27;es7&#x27;, &#x27;es8&#x27;], &#x27;es9&#x27;,&#123;name:&quot;jimmy&quot;&#125;]</span><br><span class="line">console.log(arr.includes([&quot;es7&quot;, &quot;es8&quot;])); // false</span><br><span class="line">console.log(arr.includes(&#123;name:&quot;jimmy&quot;&#125;)); // false</span><br></pre></td></tr></table></figure>

<p>能识别NaN，indexOf是不能识别NaN的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [&#x27;es6&#x27;, &#x27;es7&#x27;, NaN, &#x27;es8&#x27;]</span><br><span class="line">console.log(arr.includes(NaN)) // true</span><br><span class="line">console.log(arr.indexOf(NaN)) // -1</span><br></pre></td></tr></table></figure>

<p>最后，如果只想知道某个值是否在数组中存在，而并不关心它的索引位置，建议使用includes(),如果想获取一个值在数组中的位置，那么使用indexOf方法。</p>
<h2 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符 **"></a>幂运算符 **</h2><p>比如我们想求2的10次方。</p>
<h3 id="自己写函数实现"><a href="#自己写函数实现" class="headerlink" title="自己写函数实现"></a>自己写函数实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function pow(x, y) &#123;</span><br><span class="line">    let result = 1</span><br><span class="line">    for (let i = 0; i &lt; y; i++) &#123;</span><br><span class="line">        result *= x</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">console.log(pow(2, 10)) // 1024</span><br></pre></td></tr></table></figure>

<h3 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow()"></a>Math.pow()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.pow(2, 10)); // 1024</span><br></pre></td></tr></table></figure>

<h3 id="幂运算符-1"><a href="#幂运算符-1" class="headerlink" title="幂运算符 **"></a>幂运算符 **</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(2 ** 10); // 1024</span><br></pre></td></tr></table></figure>

<p><strong>基本求幂</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 ** 3   // 8</span><br><span class="line">3 ** 2   // 9</span><br><span class="line">3 ** 2.5 // 15.588457268119896</span><br><span class="line">10 ** -1 // 0.1</span><br><span class="line">NaN ** 2 // NaN</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>幂运算符的两个*号之间不能出现空格，否则语法会报错。</p>
<h1 id="ES2017-ES8"><a href="#ES2017-ES8" class="headerlink" title="ES2017(ES8)"></a>ES2017(ES8)</h1><h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h2><p><code>Object.values </code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  name: &quot;jimmy&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  height: 188,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Object.values(obj)); // [ &#x27;jimmy&#x27;, 18, 188 ]</span><br></pre></td></tr></table></figure>

<h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2><p>Object.entries() 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  name: &quot;jimmy&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  height: 188,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Object.entries(obj)); // [ [ &#x27;name&#x27;, &#x27;jimmy&#x27; ], [ &#x27;age&#x27;, 18 ], [ &#x27;height&#x27;, 188 ] ]</span><br><span class="line">console.log(Object.entries([1, 2, 3])); // [ [ &#x27;0&#x27;, 1 ], [ &#x27;1&#x27;, 2 ], [ &#x27;2&#x27;, 3 ] ]</span><br></pre></td></tr></table></figure>

<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p><code>Object.getOwnPropertyDescriptors() </code> 方法用来获取一个对象的所有自身属性的描述符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  name: &quot;jimmy&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">&#125;;</span><br><span class="line">const desc = Object.getOwnPropertyDescriptors(obj);</span><br><span class="line">console.log(desc);  </span><br><span class="line">// 打印结果</span><br><span class="line">&#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: &#x27;jimmy&#x27;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123; </span><br><span class="line">   value: 18, </span><br><span class="line">   writable: true,</span><br><span class="line">   enumerable: true, </span><br><span class="line">   configurable: true </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面打印结果中的</p>
<ul>
<li><code>value</code>表示当前对象的默认值</li>
<li><code>writable</code>表示对象属性是否可以修改</li>
<li><code>enumerable</code>表示当前这个属性是否可以出现在对象的枚举属性中</li>
<li><code>configurable</code>表示当前对象的属性能否用delete删除</li>
</ul>
<p>那这些对象的属性我们怎么设置和修改他们呢，我们可以使用es5的 <code>Object.defineProperty()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &quot;name&quot;, &#123;</span><br><span class="line">  value: &quot;jimmy&quot;,</span><br><span class="line">  writable: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">&#125;);</span><br><span class="line">Object.defineProperty(obj, &quot;age&quot;, &#123;</span><br><span class="line">  value: 34,</span><br><span class="line">  writable: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">&#125;);</span><br><span class="line">console.log(obj); // &#123; name: &#x27;jimmy&#x27;, age: 34 &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们演示下，一些属性设置为false的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &quot;name&quot;, &#123;</span><br><span class="line">  value: &quot;jimmy&quot;,</span><br><span class="line">  writable: false,</span><br><span class="line">  configurable: false,</span><br><span class="line">  enumerable: true,</span><br><span class="line">&#125;);</span><br><span class="line">console.log(obj); // &#123; name: &#x27;jimmy&#x27; &#125;</span><br><span class="line">obj.name = &quot;chimmy&quot;;</span><br><span class="line">console.log(obj); // &#123; name: &#x27;jimmy&#x27; &#125;</span><br><span class="line">delete obj.name</span><br><span class="line">console.log(obj); // &#123; name: &#x27;jimmy&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到设置 writable: false和configurable: false,为false时，对象的name对象的值不能改变和不能被删除，打印出来还是原来的对象。</p>
<p><strong>设置enumerable为false时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &quot;name&quot;, &#123;</span><br><span class="line">  value: &quot;jimmy&quot;,</span><br><span class="line">  writable: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: false,</span><br><span class="line">&#125;);</span><br><span class="line">console.log(obj); // &#123; &#125;</span><br><span class="line">for (let key in obj) &#123;</span><br><span class="line">  console.log(key); // &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当设置enumerable: false时，表示对象的属性不可被枚举，这时打印对象为空，遍历对象的键也为空。</p>
<h2 id="String-prototype-padStart"><a href="#String-prototype-padStart" class="headerlink" title="String.prototype.padStart"></a>String.prototype.padStart</h2><p>把指定字符串填充到字符串头部，返回新字符串。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>str.padStart(targetLength [, padString])</p>
<ul>
<li><code>targetLength</code></li>
</ul>
<p>当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p>
<ul>
<li><code>padString</code> 可选</li>
</ul>
<p>填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的默认值为 “ “</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;abc&#x27;.padStart(10);         // &quot;       abc&quot;</span><br><span class="line">&#x27;abc&#x27;.padStart(10, &quot;foo&quot;);  // &quot;foofoofabc&quot;</span><br><span class="line">&#x27;abc&#x27;.padStart(6,&quot;123465&quot;); // &quot;123abc&quot;</span><br><span class="line">&#x27;abc&#x27;.padStart(8, &quot;0&quot;);     // &quot;00000abc&quot;</span><br><span class="line">&#x27;abc&#x27;.padStart(1);          // &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>日期格式化：yyyy-mm-dd的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const now = new Date()</span><br><span class="line">const year = now.getFullYear()</span><br><span class="line">// 月份和日期 如果是一位前面给它填充一个0</span><br><span class="line">const month = (now.getMonth() + 1).toString().padStart(2, &#x27;0&#x27;)</span><br><span class="line">const day = (now.getDate()).toString().padStart(2, &#x27;0&#x27;)</span><br><span class="line">console.log(year, month, day)</span><br><span class="line">console.log( `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;` ) //输入今天的日期 2021-12-31</span><br></pre></td></tr></table></figure>

<p>数字替换(手机号，银行卡号等）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const tel = &#x27;18781268679&#x27;</span><br><span class="line">const newTel = tel.slice(-4).padStart(tel.length, &#x27;*&#x27;)</span><br><span class="line">console.log(newTel) // *******5678</span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-padEnd"><a href="#String-prototype-padEnd" class="headerlink" title="String.prototype.padEnd"></a>String.prototype.padEnd</h2><p>把指定字符串填充到字符串尾部，返回新字符串。</p>
<p>语法同上</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;abc&#x27;.padEnd(10);          // &quot;abc       &quot;</span><br><span class="line">&#x27;abc&#x27;.padEnd(10, &quot;foo&quot;);   // &quot;abcfoofoof&quot;</span><br><span class="line">&#x27;abc&#x27;.padEnd(6, &quot;123456&quot;); // &quot;abc123&quot;</span><br><span class="line">&#x27;abc&#x27;.padEnd(1);           // &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>在JS前端我们处理时间戳的时候单位是ms毫秒，但是，后端同学返回的时间戳则不一样是毫秒，可能只有10位，以s秒为单位。所以，我们在前端处理这个时间戳的时候，保险起见，要先做一个13位的补全，保证单位是毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">console.log(new Date().getTime()) // 时间戳 13位的</span><br><span class="line">timestamp = +String(timestamp).padEnd(13, &#x27;0&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="尾逗号-Trailing-commas"><a href="#尾逗号-Trailing-commas" class="headerlink" title="尾逗号 Trailing commas"></a>尾逗号 Trailing commas</h2><p>ES8 允许函数的最后一个参数有尾逗号（Trailing comma）。 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function clownsEverywhere(</span><br><span class="line">    param1,</span><br><span class="line">    param2</span><br><span class="line">) &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">    &#x27;foo&#x27;,</span><br><span class="line">    &#x27;bar&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果在param2或bar后面加一个逗号，就会报错。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接可以加上一个逗号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function clownsEverywhere(</span><br><span class="line">    param1,</span><br><span class="line">    param2,</span><br><span class="line">) &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">    &#x27;foo&#x27;,</span><br><span class="line">    &#x27;bar&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
<h2 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们都知道使用 Promise 能很好地解决回调地狱的问题，但如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程，那有没有比 Promise 更优雅的异步方式呢？那就是async&#x2F;await！我们一起来揭开它神秘的面撒吧！</p>
<p>前面添加了async的函数在执行后都会自动返回一个Promise对象:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    return &#x27;jimmy&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo()) // &#x27;jimmy&#x27;</span><br></pre></td></tr></table></figure>

<p>添加async后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">    return &#x27;jimmy&#x27; // Promise.resolve(&#x27;jimmy&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo()) // Promise</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>async函数中使用await，那么await这里的代码就会变成同步的了，意思就是说只有等await后面的Promise执行完成得到结果才会继续下去，await就是等待。请看下面的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function timeout() &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(1)</span><br><span class="line">            resolve()</span><br><span class="line">       &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不加async和await是2、1   加了是1、2</span><br><span class="line">async function foo() &#123;</span><br><span class="line">    await timeout() </span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>假如有这样一个使用场景：需要先请求 a 链接，等返回信息之后，再请求 b 链接的另外一个资源。下面代码展示的是使用 fetch 来实现这样的需求，fetch 被定义在 window 对象中，它返回的是一个 Promise 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;https://blog.csdn.net/&#x27;)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">    return fetch(&#x27;https://juejin.im/&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>虽然上述代码可以实现这个需求，但语义化不明显，代码不能很好地表示执行流程。基于这个原因，ES8 引入了 async&#x2F;await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function foo () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let response1 = await fetch(&#x27;https://blog.csdn.net/&#x27;)</span><br><span class="line">   console.log(response1)</span><br><span class="line">   let response2 = await fetch(&#x27;https://juejin.im/&#x27;)</span><br><span class="line">    console.log(response2)</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>通过上面代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这感觉就在写同步代码，所以是非常符合人的线性思维的。</p>
<h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>await 只能在 async 标记的函数内部使用，单独使用会触发 Syntax error。</li>
<li>await后面需要跟异步操作，不然就没有意义，而且await后面的Promise对象不必写then，因为await的作用之一就是获取后面Promise对象成功状态传递出来的参数。</li>
</ul>
<h3 id="async-x2F-await的缺陷"><a href="#async-x2F-await的缺陷" class="headerlink" title="async&#x2F;await的缺陷"></a>async&#x2F;await的缺陷</h3><p>了解<code>Async/await</code>是非常有用的，但还有一些缺点需要考虑。</p>
<p><code>Async/await</code> 让你的代码看起来是同步的，在某种程度上，也使得它的行为更加地同步。 <code>await</code> 关键字会阻塞其后的代码，直到promise完成，就像执行同步操作一样。它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。</p>
<p>这意味着您的代码可能会因为大量<code>await</code>的promises相继发生而变慢。每个<code>await</code>都会等待前一个完成，而你实际想要的是所有的这些promises同时开始处理（就像我们没有使用<code>async/await</code>时那样）。</p>
<p>有一种模式可以缓解这个问题——通过将 <code>Promise</code> 对象存储在变量中来同时开始它们，然后等待它们全部执行完毕。如果想更加深入的了解，请参考 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await#asyncawait%C3%A7%C2%9A%C2%84%C3%A7%C2%BC%C2%BA%C3%A9%C2%99%C2%B7">MDN</a></p>
<h1 id="ES2018-ES9"><a href="#ES2018-ES9" class="headerlink" title="ES2018(ES9)"></a>ES2018(ES9)</h1><h2 id="Object-Rest-amp-Spread"><a href="#Object-Rest-amp-Spread" class="headerlink" title="Object Rest &amp; Spread"></a>Object Rest &amp; Spread</h2><p>在 ES9 新增 Object 的 Rest &amp; Spread 方法，直接看下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const input = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const output = &#123;</span><br><span class="line">  ...input,</span><br><span class="line">  c: 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(output) // &#123;a: 1, b: 2, c: 4&#125;</span><br></pre></td></tr></table></figure>

<p>这块代码展示了 spread 语法，可以把 input 对象的数据都拓展到 output 对象，这个功能很实用。需要注意的是，<strong>如果存在相同的属性名，只有最后一个会生效</strong>。</p>
<h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; x: &#123; y: 10 &#125; &#125;;</span><br><span class="line">const copy1 = &#123; ...obj &#125;;</span><br><span class="line">const copy2 = &#123; ...obj &#125;;</span><br><span class="line">obj.x.y = &quot;jimmy&quot;;</span><br><span class="line">console.log(copy1, copy2); // x: &#123;y: &quot;jimmy&quot;&#125; x: &#123;y: &quot;jimmy&quot;&#125;</span><br><span class="line">console.log(copy1.x === copy2.x); // → true</span><br></pre></td></tr></table></figure>

<p>如果属性的值是一个对象的话，该对象的引用会被拷贝，而不是生成一个新的对象。</p>
<p>我们再来看下 <code>Object rest</code> 的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const input = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let &#123; a, ...rest &#125; = input</span><br><span class="line"></span><br><span class="line">console.log(a, rest) // 1 &#123;b: 2, c: 3&#125;</span><br></pre></td></tr></table></figure>

<p>当对象 key-value 不确定的时候，把必选的 key 赋值给变量，用一个变量收敛其他可选的 key 数据，这在之前是做不到的。注意，<strong>rest 属性必须始终出现在对象的末尾</strong>，否则将抛出错误。</p>
<h2 id="for-await-of"><a href="#for-await-of" class="headerlink" title="for await of"></a>for await of</h2><p>异步迭代器(for-await-of)：循环等待每个Promise对象变为resolved状态才进入下一步。</p>
<p>我们知道 for…of 是同步运行的，看如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function TimeOut(time)&#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            resolve(time)</span><br><span class="line">       &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function test() &#123;</span><br><span class="line">    let arr = [TimeOut(2000), TimeOut(1000), TimeOut(3000)]</span><br><span class="line">    for (let item of arr) &#123;  </span><br><span class="line">     console.log(Date.now(),item.then(console.log))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>上面打印结果如下图</p>
<p><img src="/e9770e5600d0455c987be604f0d623cbtplv-k3u1fbpfcp-watermark.png" alt="img"></p>
<p>预览</p>
<p>上述代码证实了 for of 方法不能遍历异步迭代器，得到的结果并不是我们所期待的，于是 for await of 就粉墨登场啦！</p>
<p><strong>ES9 中可以用 for…await…of 的语法来操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function TimeOut(time) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            resolve(time)</span><br><span class="line">       &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function test() &#123;</span><br><span class="line">    let arr = [TimeOut(2000), TimeOut(1000), TimeOut(3000)]</span><br><span class="line">    for await (let item of arr) &#123;</span><br><span class="line">        console.log(Date.now(), item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">// 1560092345730 2000</span><br><span class="line">// 1560092345730 1000</span><br><span class="line">// 1560092346336 3000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>for await of 环等待每个Promise对象变为resolved状态才进入下一步。所有打印的结果为 2000，1000，3000</p>
<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p>Promise.prototype.finally() 方法返回一个Promise，在promise执行结束时，无论结果是fulfilled或者是rejected，在执行then()和catch()后，都会执行finally指定的回调函数。这为指定执行完promise后，无论结果是fulfilled还是rejected都需要执行的代码提供了一种方式，避免同样的语句需要在then()和catch()中各写一次的情况。</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&#x27;success&#x27;)</span><br><span class="line">        // reject(&#x27;fail&#x27;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;).finally(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p><strong>loading关闭</strong></p>
<p>需要每次发送请求，都会有loading提示，请求发送完毕，就需要关闭loading提示框，不然界面就无法被点击。不管请求成功或是失败，这个loading都需要关闭掉，这时把关闭loading的代码写在finally里再合适不过了</p>
<h2 id="String-扩展"><a href="#String-扩展" class="headerlink" title="String 扩展"></a>String 扩展</h2><p>放松对标签模板里字符串转义的限制, 遇到不合法的字符串转义会返回undefined，并且从raw上可获取原字符串。</p>
<p>下面是一个es6 的标签模板 如果对这个语法感到陌生，请参考 [标签模板](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/string#%C3%A6">https://es6.ruanyifeng.com/#docs/string#æ</a> ç­¾æ¨¡æ¿)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const foo = (a, b, c) =&gt; &#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(b)</span><br><span class="line">    console.log(c)</span><br><span class="line">&#125;</span><br><span class="line">const name = &#x27;jimmy&#x27;</span><br><span class="line">const age = 18</span><br><span class="line">foo `这是$&#123;name&#125;,他的年龄是$&#123;age&#125;岁` </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数打印如下： </p>
<p><img src="/6db7b7356279465d85c197b9d284425dtplv-k3u1fbpfcp-watermark.png" alt="img"></p>
<p>预览</p>
<p>ES9开始，模板字符串允许嵌套支持常见转义序列，移除对ECMAScript在带标签的模版字符串中转义序列的语法限制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo(a, b, c) &#123;</span><br><span class="line">    console.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">// 在标签函数中使用 </span><br><span class="line">// unicode字符%u&#123;61&#125; 对应的值为 a</span><br><span class="line">// unicode字符%u&#123;62&#125; 对应的值为 b</span><br><span class="line">// %unicode 是一个无效的unicode字符</span><br><span class="line">foo `%u&#123;61&#125; and %u&#123;62&#125;` </span><br><span class="line">foo `%u&#123;61&#125; and %unicode`  </span><br></pre></td></tr></table></figure>



<p><img src="/5d484a5ff27d4001948e2f7955d3ba7ctplv-k3u1fbpfcp-watermark.png" alt="img"></p>
<p>预览</p>
<h3 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a>注意点</h3><p>在模板字符串中，如果输入无效的unicode字符，还是会报错。只有在便签模板中 从es9开始才不会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let string = `%u&#123;61&#125; and %unicode`;</span><br><span class="line">console.log(string); // Uncaught SyntaxError: Invalid Unicode escape sequence</span><br></pre></td></tr></table></figure>

<h1 id="ES2019-ES10"><a href="#ES2019-ES10" class="headerlink" title="ES2019(ES10)"></a>ES2019(ES10)</h1><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p>方法 Object.fromEntries() 把键值对列表转换为一个对象，这个方法是和 Object.entries() 相对的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.fromEntries([</span><br><span class="line">    [&#x27;foo&#x27;, 1],</span><br><span class="line">    [&#x27;bar&#x27;, 2]</span><br><span class="line">])</span><br><span class="line">// &#123;foo: 1, bar: 2&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例1：Object-转换操作"><a href="#案例1：Object-转换操作" class="headerlink" title="案例1：Object 转换操作"></a>案例1：Object 转换操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    name: &#x27;jimmy&#x27;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">const entries = Object.entries(obj)</span><br><span class="line">console.log(entries)</span><br><span class="line">// [Array(2), Array(2)]</span><br><span class="line"></span><br><span class="line">// ES10</span><br><span class="line">const fromEntries = Object.fromEntries(entries)</span><br><span class="line">console.log(fromEntries)</span><br><span class="line">// &#123;name: &quot;jimmy&quot;, age: 18&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例2：Map-转-Object"><a href="#案例2：Map-转-Object" class="headerlink" title="案例2：Map 转 Object"></a>案例2：Map 转 Object</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map()</span><br><span class="line">map.set(&#x27;name&#x27;, &#x27;jimmy&#x27;)</span><br><span class="line">map.set(&#x27;age&#x27;, 18)</span><br><span class="line">console.log(map) // &#123;&#x27;name&#x27; =&gt; &#x27;jimmy&#x27;, &#x27;age&#x27; =&gt; 18&#125;</span><br><span class="line"></span><br><span class="line">const obj = Object.fromEntries(map)</span><br><span class="line">console.log(obj)</span><br><span class="line">// &#123;name: &quot;jimmy&quot;, age: 18&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例3：过滤"><a href="#案例3：过滤" class="headerlink" title="案例3：过滤"></a>案例3：过滤</h3><p>course表示所有课程，想请求课程分数大于80的课程组成的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const course = &#123;</span><br><span class="line">    math: 80,</span><br><span class="line">    english: 85,</span><br><span class="line">    chinese: 90</span><br><span class="line">&#125;</span><br><span class="line">const res = Object.entries(course).filter(([key, val]) =&gt; val &gt; 80)</span><br><span class="line">console.log(res) // [ [ &#x27;english&#x27;, 85 ], [ &#x27;chinese&#x27;, 90 ] ]</span><br><span class="line">console.log(Object.fromEntries(res)) // &#123; english: 85, chinese: 90 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例4：url的search参数转换"><a href="#案例4：url的search参数转换" class="headerlink" title="案例4：url的search参数转换"></a>案例4：url的search参数转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// let url = &quot;https://www.baidu.com?name=jimmy&amp;age=18&amp;height=1.88&quot;</span><br><span class="line">// queryString 为 window.location.search</span><br><span class="line">const queryString = &quot;?name=jimmy&amp;age=18&amp;height=1.88&quot;;</span><br><span class="line">const queryParams = new URLSearchParams(queryString);</span><br><span class="line">const paramObj = Object.fromEntries(queryParams);</span><br><span class="line">console.log(paramObj); // &#123; name: &#x27;jimmy&#x27;, age: &#x27;18&#x27;, height: &#x27;1.88&#x27; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let newArray = arr.flat([depth])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>depth</code> 可选 指定要提取嵌套数组的结构深度，默认值为 1。</li>
</ul>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p><code>flat() </code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [0, 1, 2, [3, 4]];</span><br><span class="line">console.log(arr1.flat());  //  [0, 1, 2, 3, 4]</span><br><span class="line">const arr2 = [0, 1, 2, [[[3, 4]]]];</span><br><span class="line">console.log(arr2.flat(2));  //  [0, 1, 2, [3, 4]]</span><br><span class="line"></span><br><span class="line">//使用 Infinity，可展开任意深度的嵌套数组</span><br><span class="line">var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];</span><br><span class="line">arr4.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line"></span><br><span class="line">// `flat()` 方法会移除数组中的空项:</span><br><span class="line">var arr5 = [1, 2, , 4, 5];</span><br><span class="line">arr5.flat(); // [1, 2, 4, 5]</span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h2><p>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。从方法的名字上也可以看出来它包含两部分功能一个是 map，一个是 flat（深度为1）。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) &#123;</span><br><span class="line">    // 返回新数组的元素</span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>callback</code></li>
</ul>
<p>可以生成一个新数组中的元素的函数，可以传入三个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentValue</span><br></pre></td></tr></table></figure>

<p>当前正在数组中处理的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index</span><br></pre></td></tr></table></figure>

<p>可选 数组中正在处理的当前元素的索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array</span><br></pre></td></tr></table></figure>

<p>可选 被调用的 <code>map</code> 数组</p>
<ul>
<li><code>thisArg</code>可选</li>
</ul>
<p>执行 <code>callback</code> 函数时 使用的<code>this</code> 值。</p>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3]</span><br><span class="line">numbers.map(x =&gt; [x * 2]) // [[2], [4], [6]]</span><br><span class="line">numbers.flatMap(x =&gt; [x * 2]) // [2, 4, 6]</span><br></pre></td></tr></table></figure>

<p>这个示例可以简单对比下 map 和 flatMap 的区别。当然还可以看下下面的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;今天天气不错&#x27;, &#x27;&#x27;, &#x27;早上好&#x27;]</span><br><span class="line">arr.map(s =&gt; s.split(&#x27;&#x27;))</span><br><span class="line">// [[&quot;今&quot;, &quot;天&quot;, &quot;天&quot;, &quot;气&quot;, &quot;不&quot;, &quot;错&quot;],[&quot;&quot;],[&quot;早&quot;, &quot;上&quot;, &quot;好&quot;]]</span><br><span class="line">arr.flatMap(s =&gt; s.split(&#x27;&#x27;))</span><br><span class="line">// [&quot;今&quot;, &quot;天&quot;, &quot;天&quot;, &quot;气&quot;, &quot;不&quot;, &quot;错&quot;, &quot;&quot;, &quot;早&quot;, &quot;上&quot;, &quot;好&quot;]</span><br></pre></td></tr></table></figure>

<p><code>flatMap</code> 方法与 <code>map</code> 方法和深度depth为1的 <code>flat</code> 几乎相同.</p>
<h2 id="String-prototype-trimStart"><a href="#String-prototype-trimStart" class="headerlink" title="String.prototype.trimStart()"></a>String.prototype.trimStart()</h2><p>trimStart() 方法从字符串的开头删除空格，trimLeft()是此方法的别名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;   foo  &#x27;</span><br><span class="line">console.log(str.length) // 8</span><br><span class="line">str = str.trimStart() // 或str.trimLeft()</span><br><span class="line">console.log(str.length) // 5</span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-trimEnd"><a href="#String-prototype-trimEnd" class="headerlink" title="String.prototype.trimEnd()"></a>String.prototype.trimEnd()</h2><p>trimEnd() 方法从一个字符串的右端移除空白字符，trimRight 是 trimEnd 的别名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;   foo  &#x27;</span><br><span class="line">console.log(str.length) // 8</span><br><span class="line">str = str.trimEnd() // 或str.trimRight()</span><br><span class="line">console.log(str.length) // 6</span><br></pre></td></tr></table></figure>

<h2 id="可选的Catch-Binding"><a href="#可选的Catch-Binding" class="headerlink" title="可选的Catch Binding"></a>可选的Catch Binding</h2><p>在 ES10 之前我们都是这样捕获异常的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // tryCode</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">    // catchCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里 err 是必须的参数，在 ES10 可以省略这个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    console.log(&#x27;Foobar&#x27;)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    console.error(&#x27;Bar&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>验证参数是否为json格式</strong></p>
<p>这个需求我们只需要返回true或false，并不关心catch的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const validJSON = json =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        JSON.parse(json)</span><br><span class="line">        return true</span><br><span class="line">   &#125; catch &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>我们知道，Symbol 的描述只被存储在内部的 <code>Description</code> ，没有直接对外暴露，我们只有调用 Symbol 的 toString() 时才可以读取这个属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const name = Symbol(&#x27;es&#x27;)</span><br><span class="line">console.log(name.toString()) // Symbol(es)</span><br><span class="line">console.log(name) // Symbol(es)</span><br><span class="line">console.log(name === &#x27;Symbol(es)&#x27;) // false</span><br><span class="line">console.log(name.toString() === &#x27;Symbol(es)&#x27;) // true</span><br></pre></td></tr></table></figure>

<p>现在可以通过 description 方法获取 Symbol 的描述:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const name = Symbol(&#x27;es&#x27;)</span><br><span class="line">console.log(name.description) // es</span><br><span class="line">name.description = &quot;es2&quot; // 只读属性 并不能修改描述符</span><br><span class="line">console.log(name.description === &#x27;es&#x27;) // true</span><br><span class="line">// 如果没有描述符 输入undefined</span><br><span class="line">const s2 = Symbol()</span><br><span class="line">console.log(s2.description) // undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JSON-stringify-增强能力"><a href="#JSON-stringify-增强能力" class="headerlink" title="JSON.stringify() 增强能力"></a>JSON.stringify() 增强能力</h2><p>JSON.stringify 在 ES10 修复了对于一些超出范围的 Unicode 展示错误的问题。因为 JSON 都是被编码成 UTF-8，所以遇到 0xD800–0xDFFF 之内的字符会因为无法编码成 UTF-8 进而导致显示错误。在 ES10 它会用转义字符的方式来处理这部分字符而非编码的方式，这样就会正常显示了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 😎  emoji 多字节的一个字符</span><br><span class="line">console.log(JSON.stringify(&#x27;😎&#x27;)) // 打印出笑脸</span><br><span class="line"></span><br><span class="line">// 如果我们只去其中的一部分  � 这其实是个无效的字符串</span><br><span class="line">// 之前的版本 ，这些字符将替换为特殊字符，而现在将未配对的代理代码点表示为JSON转义序列</span><br><span class="line">console.log(JSON.stringify(&#x27;�&#x27;)) // &quot;�&quot;</span><br></pre></td></tr></table></figure>

<h2 id="修订-Function-prototype-toString"><a href="#修订-Function-prototype-toString" class="headerlink" title="修订 Function.prototype.toString()"></a>修订 Function.prototype.toString()</h2><p>以前函数的toString方法来自Object.prototype.toString(),现在的 Function.prototype.toString() 方法返回一个表示当前函数源代码的字符串。以前只会返回这个函数，不包含注释、空格等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    // es10新特性</span><br><span class="line">    console.log(&#x27;imooc&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo.toString()) </span><br><span class="line">// 打印如下</span><br><span class="line">// function foo() &#123;</span><br><span class="line">//  // es10新特性</span><br><span class="line">//  console.log(&quot;imooc&quot;);</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<p>将返回注释、空格和语法等详细信息。</p>
<h1 id="ES2020-ES11"><a href="#ES2020-ES11" class="headerlink" title="ES2020(ES11)"></a>ES2020(ES11)</h1><h2 id="空值合并运算符（Nullish-coalescing-Operator）"><a href="#空值合并运算符（Nullish-coalescing-Operator）" class="headerlink" title="空值合并运算符（Nullish coalescing Operator）"></a>空值合并运算符（Nullish coalescing Operator）</h2><p><strong>空值合并操作符</strong>（ <code>??</code> ）是一个逻辑操作符，当左侧的操作数为 <code>null</code>或者<code>undefined</code>时，返回其右侧操作数，否则返回左侧操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const foo = undefined ?? &quot;foo&quot;</span><br><span class="line">const bar = null ?? &quot;bar&quot;</span><br><span class="line">console.log(foo) // foo</span><br><span class="line">console.log(bar) // bar</span><br></pre></td></tr></table></figure>

<p>与逻辑或操作符（<code>||</code>）不同，逻辑或操作符会在左侧操作数为假值时返回右侧操作数。也就是说，如果使用 <code>||</code> 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如<code>&#39;&#39;</code>,<code>0</code>,<code>NaN</code>,<code>false</code>）时。见下面的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const foo = &quot;&quot; ?? &#x27;default string&#x27;;</span><br><span class="line">const foo2 = &quot;&quot; || &#x27;default string&#x27;;</span><br><span class="line">console.log(foo); // &quot;&quot;</span><br><span class="line">console.log(foo2); // &quot;default string&quot;</span><br><span class="line"></span><br><span class="line">const baz = 0 ?? 42;</span><br><span class="line">const baz2 = 0 || 42;</span><br><span class="line">console.log(baz); // 0</span><br><span class="line">console.log(baz2); // 42</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a>注意点</h3><p>将 <code>??</code> 直接与 AND（<code>&amp;&amp;</code>）和 OR（<code>||</code>）操作符组合使用是不可取的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null || undefined ?? &quot;foo&quot;; // 抛出 SyntaxError</span><br><span class="line">true || undefined ?? &quot;foo&quot;; // 抛出 SyntaxError</span><br></pre></td></tr></table></figure>

<h2 id="可选链-Optional-chaining"><a href="#可选链-Optional-chaining" class="headerlink" title="可选链 Optional chaining"></a>可选链 Optional chaining</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><strong>可选链</strong>操作符( <code>?.</code> )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。<code>?.</code> 操作符的功能类似于 <code>.</code> 链式操作符，不同之处在于，在引用为 <code>null</code> 或者 <code>undefined</code> 的情况下不会引起错误，该表达式短路返回值是 <code>undefined</code>。与函数调用一起使用时，如果给定的函数不存在，则返回 <code>undefined</code>。</p>
<p>当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链操作符也是很有帮助的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">    address: &#123;</span><br><span class="line">        street: &#x27;xx街道&#x27;,</span><br><span class="line">        getNum() &#123;</span><br><span class="line">            return &#x27;80号&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在之前的语法中，想获取到深层属性或方法，不得不做前置校验，否则很容易命中 <code>Uncaught TypeError: Cannot read property...</code> 这种错误，这极有可能让你整个应用挂掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const street = user &amp;&amp; user.address &amp;&amp; user.address.street</span><br><span class="line">const num = user &amp;&amp; user.address &amp;&amp; user.address.getNum &amp;&amp; user.address.getNum()</span><br><span class="line">console.log(street, num)</span><br></pre></td></tr></table></figure>

<p>用了 Optional Chaining ，上面代码会变成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const street2 = user?.address?.street</span><br><span class="line">const num2 = user?.address?.getNum?.()</span><br><span class="line">console.log(street2, num2)</span><br></pre></td></tr></table></figure>

<p>可选链中的 ? 表示如果问号左边表达式有值, 就会继续查询问号后面的字段。根据上面可以看出，用可选链可以大量简化类似繁琐的前置校验操作，而且更安全。</p>
<h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 对象中使用</span><br><span class="line">let obj = &#123;</span><br><span class="line">  name: &quot;jimmy&quot;,</span><br><span class="line">  age: &quot;18&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">let property = &quot;age&quot;;</span><br><span class="line">let name = obj?.name;</span><br><span class="line">let age = obj?.age;</span><br><span class="line">let ages = obj?.[property];</span><br><span class="line">let sex = obj?.sex;</span><br><span class="line">console.log(name); // jimmy</span><br><span class="line">console.log(age); // 18</span><br><span class="line">console.log(ages); // 18</span><br><span class="line">console.log(sex); // undefined</span><br><span class="line"></span><br><span class="line">// 数组中使用</span><br><span class="line">let arr = [1,2,2];</span><br><span class="line">let arrayItem = arr?.[42]; // undefined</span><br><span class="line"></span><br><span class="line">// 函数中使用</span><br><span class="line">let obj = &#123;</span><br><span class="line"> func: function () &#123;</span><br><span class="line">   console.log(&quot;I am func&quot;);</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj?.func(); // I am func</span><br></pre></td></tr></table></figure>

<h3 id="与空值合并操作符一起使用"><a href="#与空值合并操作符一起使用" class="headerlink" title="与空值合并操作符一起使用"></a>与空值合并操作符一起使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let customer = &#123;</span><br><span class="line">  name: &quot;jimmy&quot;,</span><br><span class="line">  details: &#123; age: 18 &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let customerCity = customer?.city ?? &quot;成都&quot;;</span><br><span class="line">console.log(customerCity); // &quot;成都&quot;</span><br></pre></td></tr></table></figure>

<h3 id="注意点-5"><a href="#注意点-5" class="headerlink" title="注意点"></a>注意点</h3><p><strong>可选链不能用于赋值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let object = &#123;&#125;;</span><br><span class="line">object?.property = 1; // Uncaught SyntaxError: Invalid left-hand side in assignment</span><br></pre></td></tr></table></figure>

<h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><p>在以前，从不同的 JavaScript 环境中获取全局对象需要不同的语句。在 Web 中，可以通过 <code>window</code>、<code>self</code> 取到全局对象，在 Node.js 中，它们都无法获取，必须使用 <code>global</code>。</p>
<p>在松散模式下，可以在函数中返回 <code>this</code> 来获取全局对象，但是在严格模式和模块环境下，<code>this</code> 会返回 <code>undefined</code>。</p>
<p>以前想要获取全局对象，可通过一个全局函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const getGlobal = () =&gt; &#123;</span><br><span class="line">    if (typeof self !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof window !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">        return window</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof global !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">        return global</span><br><span class="line">    &#125;</span><br><span class="line">    throw new Error(&#x27;无法找到全局对象&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const globals = getGlobal()</span><br><span class="line">console.log(globals)</span><br></pre></td></tr></table></figure>

<p>现在<code>globalThis</code> 提供了一个标准的方式来获取不同环境下的全局 <code>this</code> 对象（也就是全局对象自身）。不像 <code>window</code> 或者 <code>self</code> 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 <code>globalThis</code>，不必担心它的运行环境。</p>
<p>为便于记忆，你只需要记住，全局作用域中的 <code>this</code> 就是<code>globalThis</code>。以后就用globalThis就行了。</p>
<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p><strong><code>BigInt</code></strong> 是一种内置对象，它提供了一种方法来表示大于 <code>2的53次方 - 1</code> 的整数。这原本是 Javascript中可以用 <code>Number</code> 表示的最大数字。**<code>BigInt</code>** 可以表示任意大的整数。</p>
<p><strong>使用 BigInt 有两种方式：</strong></p>
<h3 id="方式一：数字后面增加n"><a href="#方式一：数字后面增加n" class="headerlink" title="方式一：数字后面增加n"></a>方式一：数字后面增加n</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const bigInt = 9007199254740993n</span><br><span class="line">console.log(bigInt)</span><br><span class="line">console.log(typeof bigInt) // bigint</span><br><span class="line"></span><br><span class="line">// `BigInt` 和 [`Number`]不是严格相等的，但是宽松相等的。</span><br><span class="line">console.log(1n == 1) // true</span><br><span class="line">console.log(1n === 1) // false</span><br><span class="line"></span><br><span class="line">// `Number` 和 `BigInt` 可以进行比较。</span><br><span class="line">1n &lt; 2 // ↪ true</span><br><span class="line">2n &gt; 1 // ↪ true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="方式二：使用-BigInt-函数"><a href="#方式二：使用-BigInt-函数" class="headerlink" title="方式二：使用 BigInt 函数"></a>方式二：使用 BigInt 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const bigIntNum = BigInt(9007199254740993n)</span><br><span class="line">console.log(bigIntNum)</span><br></pre></td></tr></table></figure>

<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let number = BigInt(2);</span><br><span class="line">let a = number + 2n; // 4n</span><br><span class="line">let b = number * 10n; // 20n</span><br><span class="line">let c = number - 10n; // -8n</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(c);</span><br></pre></td></tr></table></figure>

<h3 id="注意点-6"><a href="#注意点-6" class="headerlink" title="注意点"></a>注意点</h3><p>BigInt不能用于 [<code>Math</code>] 对象中的方法；不能和任何 [<code>Number</code>] 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 <code>BigInt</code> 变量在转换成 [<code>Number</code>] 变量时可能会丢失精度。</p>
<h2 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll()"></a>String.prototype.matchAll()</h2><p><strong><code>matchAll()</code></strong> 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const regexp = /t(e)(st(d?))/g;</span><br><span class="line">const str = &#x27;test1test2&#x27;;</span><br><span class="line"></span><br><span class="line">const array = [...str.matchAll(regexp)];</span><br><span class="line">console.log(array[0]);  // [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]</span><br><span class="line">console.log(array[1]); // [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p>我们都知道 Promise.all() 具有并发执行异步任务的能力。但它的最大问题就是如果其中某个任务出现异常(reject)，所有任务都会挂掉，Promise直接进入reject 状态。</p>
<p>场景：现在页面上有三个请求，分别请求不同的数据，如果一个接口服务异常，整个都是失败的，都无法渲染出数据</p>
<p>我们需要一种机制，如果并发任务中，无论一个任务正常或者异常，都会返回对应的的状态，这就是<code>Promise.allSettled</code>的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = () =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;promise1&quot;);</span><br><span class="line">      //   reject(&quot;error promise1 &quot;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">const promise2 = () =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;promise2&quot;);</span><br><span class="line">      //   reject(&quot;error promise2 &quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"> promise3 = () =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      //   resolve(&quot;promise3&quot;);</span><br><span class="line">      reject(&quot;error promise3 &quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  Promise.all 会走到catch里面</span><br><span class="line">Promise.all([promise1(), promise2(), promise3()])</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); </span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.log(&quot;error&quot;, error); // error promise3 </span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">// Promise.allSettled 不管有没有错误，三个的状态都会返回</span><br><span class="line">Promise.allSettled([promise1(), promise2(), promise3()])</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res);  </span><br><span class="line">    // 打印结果 </span><br><span class="line">    // [</span><br><span class="line">    //    &#123;status: &#x27;fulfilled&#x27;, value: &#x27;promise1&#x27;&#125;, </span><br><span class="line">    //    &#123;status: &#x27;fulfilled&#x27;,value: &#x27;promise2&#x27;&#125;,</span><br><span class="line">    //    &#123;status: &#x27;rejected&#x27;, reason: &#x27;error promise3 &#x27;&#125;</span><br><span class="line">    // ]</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.log(&quot;error&quot;, error); </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Dynamic-Import（按需-import）"><a href="#Dynamic-Import（按需-import）" class="headerlink" title="Dynamic Import（按需 import）"></a>Dynamic Import（按需 import）</h2><p><code>import()</code>可以在需要的时候，再加载某个模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&#x27;click&#x27;, event =&gt; &#123;</span><br><span class="line">  import(&#x27;./dialogBox.js&#x27;)</span><br><span class="line">  .then(dialogBox =&gt; &#123;</span><br><span class="line">    dialogBox.open();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    /* Error handling */</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p>
<h1 id="ES2021-ES12"><a href="#ES2021-ES12" class="headerlink" title="ES2021(ES12)"></a>ES2021(ES12)</h1><h2 id="逻辑运算符和赋值表达式（-amp-amp-x3D-，-x3D-，-x3D-）"><a href="#逻辑运算符和赋值表达式（-amp-amp-x3D-，-x3D-，-x3D-）" class="headerlink" title="逻辑运算符和赋值表达式（&amp;&amp;&#x3D;，||&#x3D;，??&#x3D;）"></a>逻辑运算符和赋值表达式（&amp;&amp;&#x3D;，||&#x3D;，??&#x3D;）</h2><h3 id="amp-amp-x3D"><a href="#amp-amp-x3D" class="headerlink" title="&amp;&amp;&#x3D;"></a>&amp;&amp;&#x3D;</h3><p>逻辑与赋值 <code>x &amp;&amp;= y</code>等效于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &amp;&amp; (x = y);</span><br></pre></td></tr></table></figure>

<p>上面的意思是，当x为真时，x&#x3D;y。 具体请看下面的示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = 0;</span><br><span class="line"></span><br><span class="line">a &amp;&amp;= 2;</span><br><span class="line">console.log(a); // 2</span><br><span class="line"></span><br><span class="line">b &amp;&amp;= 2;</span><br><span class="line">console.log(b);  // 0</span><br></pre></td></tr></table></figure>

<h3 id="x3D"><a href="#x3D" class="headerlink" title="||&#x3D;"></a>||&#x3D;</h3><p>逻辑或赋值（<code>x ||= y</code>）运算仅在 <code>x</code> 为false时赋值。</p>
<p><strong><code>x ||= y</code> 等同于：x || (x &#x3D; y);</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1const a = &#123; duration: 50, title: &#x27;&#x27; &#125;;</span><br><span class="line"></span><br><span class="line">a.duration ||= 10;</span><br><span class="line">console.log(a.duration); // 50</span><br><span class="line"></span><br><span class="line">a.title ||= &#x27;title is empty.&#x27;;</span><br><span class="line">console.log(a.title); // &quot;title is empty&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="x3D-1"><a href="#x3D-1" class="headerlink" title="??&#x3D;"></a>??&#x3D;</h3><p>逻辑空赋值运算符 (<code>x ??= y</code>) 仅在 <code>x</code> 是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish">nullish</a> (<code>null</code> 或 <code>undefined</code>) 时对其赋值。</p>
<p><strong><code>x ??= y</code> 等价于： x ?? (x &#x3D; y);</strong></p>
<p><strong>示例一</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const a = &#123; duration: 50 &#125;;</span><br><span class="line"></span><br><span class="line">a.duration ??= 10;</span><br><span class="line">console.log(a.duration); // 50</span><br><span class="line"></span><br><span class="line">a.speed ??= 25;</span><br><span class="line">console.log(a.speed); // 25</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function config(options) &#123;</span><br><span class="line">  options.duration ??= 100;</span><br><span class="line">  options.speed ??= 25;</span><br><span class="line">  return options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config(&#123; duration: 125 &#125;); // &#123; duration: 125, speed: 25 &#125;</span><br><span class="line">config(&#123;&#125;); // &#123; duration: 100, speed: 25 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-replaceAll"><a href="#String-prototype-replaceAll" class="headerlink" title="String.prototype.replaceAll()"></a>String.prototype.replaceAll()</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p><code>replaceAll()</code> 方法返回一个新字符串，新字符串中所有满足 <code>pattern</code> 的部分都会被<code>replacement</code> 替换。<code>pattern</code>可以是一个字符串或一个<code>RegExp</code>，<code>replacement</code>可以是一个字符串或一个在每次匹配被调用的函数。</p>
<p>原始字符串保持不变。</p>
<h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;aabbcc&#x27;.replaceAll(&#x27;b&#x27;, &#x27;.&#x27;); // &#x27;aa..cc&#x27;</span><br></pre></td></tr></table></figure>

<p>使用正则表达式搜索值时，它必须是全局的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;aabbcc&#x27;.replaceAll(/b/, &#x27;.&#x27;);</span><br><span class="line">TypeError: replaceAll must be called with a global RegExp</span><br></pre></td></tr></table></figure>

<p>这将可以正常运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;aabbcc&#x27;.replaceAll(/b/g, &#x27;.&#x27;);</span><br><span class="line">&quot;aa..cc&quot;</span><br></pre></td></tr></table></figure>

<h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a><strong>数字分隔符</strong></h2><p>欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如，<code>1000</code>可以写作<code>1,000</code>。</p>
<p><code>ES2021</code>中允许 JavaScript 的数值使用下划线（<code>_</code>）作为分隔符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let budget = 1_000_000_000_000;</span><br><span class="line">budget === 10 ** 12 // true</span><br></pre></td></tr></table></figure>

<p>这个数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123_00 === 12_300 // true</span><br><span class="line"></span><br><span class="line">12345_00 === 123_4500 // true</span><br><span class="line">12345_00 === 1_234_500 // true</span><br></pre></td></tr></table></figure>

<p>小数和科学计数法也可以使用数值分隔符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 小数</span><br><span class="line">0.000_001</span><br><span class="line"></span><br><span class="line">// 科学计数法</span><br><span class="line">1e10_000</span><br></pre></td></tr></table></figure>

<p>数值分隔符有几个使用注意点。</p>
<ul>
<li>不能放在数值的最前面（leading）或最后面（trailing）。</li>
<li>不能两个或两个以上的分隔符连在一起。</li>
<li>小数点的前后不能有分隔符。</li>
<li>科学计数法里面，表示指数的<code>e</code>或<code>E</code>前后不能有分隔符。</li>
</ul>
<p>下面的写法都会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">3_.141</span><br><span class="line">3._141</span><br><span class="line">1_e12</span><br><span class="line">1e_12</span><br><span class="line">123__456</span><br><span class="line">_1464301</span><br><span class="line">1464301_</span><br></pre></td></tr></table></figure>

<h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a><strong>Promise.any</strong></h2><p>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = () =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;promise1&quot;);</span><br><span class="line">      //  reject(&quot;error promise1 &quot;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">const promise2 = () =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;promise2&quot;);</span><br><span class="line">      // reject(&quot;error promise2 &quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">const promise3 = () =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;promise3&quot;);</span><br><span class="line">      // reject(&quot;error promise3 &quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Promise.any([promise1(), promise2(), promise3()])</span><br><span class="line">  .then((first) =&gt; &#123;</span><br><span class="line">    // 只要有一个请求成功 就会返回第一个请求成功的</span><br><span class="line">    console.log(first); // 会返回promise2</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    // 所有三个全部请求失败 才会来到这里</span><br><span class="line">    console.log(&quot;error&quot;, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p>

                
                <p class="end">__END__</p>
            </div>
            <div class="article-footer">
                <div class="suffix-box">
    <div class="suffix-box-left">
        <img src="/image/sidebar/avatar.jpg" alt="Moooodena">
    </div>
    <div class="suffix-box-right">
        <span class="suffix-box-title">文章作者：</span>Moooodena
        <br>
        <span class="suffix-box-title">文章出处：</span><a href="/2022/10/21/13.%20%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" target="_blank">ES6-ES12相关</a>
        <br>
        <span class="suffix-box-title">作者签名：</span>简单地活着, 肆意又精彩.
        <br>
        <span class="suffix-box-title">关于主题：</span><a href="https://github.com/first19326/Hexo-LiveForCode" target="_blank">Hexo - Live For Code</a>
        <br>
        <span class="suffix-box-title">版权声明：</span>文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议，转载请注明出处
        <br>
    </div>
    <div style="clear: both;"></div>
</div>
                
                
                <div class="article-prev-next">
                    
                        <a href="/2022/10/28/14.%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/" class="prev-prefix">« </a> 上一篇：    <a href="/2022/10/28/14.%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/" title="发布于 2022-10-28 08:57">代码优化相关(持续更新)</a>
                        <br>
                    
                    
                        <a href="/2022/09/15/Vue/" class="next-prefix">» </a> 下一篇：    <a href="/2022/09/15/Vue/" title="发布于 2022-09-15 07:53">Vue基础（持续更新）</a>
                    
                </div>
            </div>
            
    <div class="article-comments">
        
            <div class="comments-title">
                评论列表
            </div>
        
        <div class="comments-content"></div>
    </div>

        </div>
    
</div>
    <div id="footer"></div>
    <div id="sidebar">
    <div class="menu-wrap" style="display:none;">
        
            <div class="menu-notice">
                <span class="iconfont icon-notice"></span>
                <div class="notice">
                    <span>简单地活着，肆意而又精彩！</span>
                </div>
            </div>
        
        <nav class="menu">
            <div class="menu-introduce"> 
                <div class="introduce-avatar">
                    <img src="/image/sidebar/avatar.jpg">
                </div> 
                <div class="introduce-info"> 
                    <div class="introduce-user"><span>Moooodena</span></div>
                </div> 
            </div> 
            <div class="menu-list">
                <ul>
                    
                        <li class=""><a href="/" class="" target="_self"><span class="iconfont icon-home-fill"></span>首页</a></li>
                    
                        <li class=""><a href="/category" class="" target="_self"><span class="iconfont icon-folder-fill"></span>分类</a></li>
                    
                        <li class=""><a href="/tag" class="" target="_self"><span class="iconfont icon-discount-fill"></span>标签</a></li>
                    
                        <li class=""><a href="/archive" class="" target="_self"><span class="iconfont icon-calendar-fill"></span>归档</a></li>
                    
                        <li class=""><a href="/donate" class="" target="_self"><span class="iconfont icon-heart-fill"></span>赞赏</a></li>
                    
                        <li class=""><a href="/about" class="" target="_self"><span class="iconfont icon-about-fill"></span>关于</a></li>
                    
                        <li class=""><a href="/atom.xml" class="" target="_blank"><span class="iconfont icon-rss"></span>订阅</a></li>
                    
                        <li class=""><a href="javascript:;" class="search" target="_self"><span class="iconfont icon-search-menu"></span>搜索</a></li>
                    
                        <li class=""><a href="/comment" class="" target="_self"><span class="iconfont icon-comments-fill"></span>留言板</a></li>
                    
                        <li class=""><a href="/friend" class="" target="_self"><span class="iconfont icon-link"></span>友情链接</a></li>
                    
                </ul> 
            </div> 
            <div class="menu-link">
                <div class="box">
                    <div class="image-box"></div>
                </div>
                
                    <a name="知乎" href="" class="" target="_blank" data=""><span class="iconfont icon-zhihu"></span></a>
                
                    <a name="微博" href="" class="" target="_blank" data=""><span class="iconfont icon-weibo"></span></a>
                
                    <a name="QQ" href="javascript:;" class="image" target="_self" data="/image/sidebar/qq.png"><span class="iconfont icon-qq"></span></a>
                
                    <a name="微信" href="javascript:;" class="image" target="_self" data="/image/sidebar/Wechat.png"><span class="iconfont icon-wechat"></span></a>
                
                    <a name="GitHub" href="https://github.com/Moooodena" class="" target="_blank" data=""><span class="iconfont icon-github"></span></a>
                
            </div> 
        </nav>
        <button class="menu-button-close"></button>
        <div class="morph-shape" id="morph-shape" data-morph-open="M-7.312,0H15c0,0,66,113.339,66,399.5C81,664.006,15,800,15,800H-7.312V0z;M-7.312,0H100c0,0,0,113.839,0,400c0,264.506,0,400,0,400H-7.312V0z">
            <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 800" preserveAspectRatio="none">
                <path d="M-7.312,0H0c0,0,0,113.839,0,400c0,264.506,0,400,0,400h-7.312V0z"/>
            </svg>
        </div>
    </div>
    <button class="menu-button-open">MENU</button>
    <div class="menu-cover"></div>
</div>
    <link type="text/css" rel="stylesheet" href="/css/search.css">
<script type="text/javascript" src="/js/iscroll.js"></script>
<script type="text/javascript" src="/js/instantsearch.min.js"></script>
<div class="search-window">
    <div class="search-content">
        <div class="search-content-icon">
            <i class="iconfont icon-search"></i>
        </div>
        <div id="search-input" class="search-input"></div>
    </div>

    <div class="search-scroll">
        <div class="search-result">
            <div id="search-stats" class="search-stats"></div>
            <div id="search-hits"></div>
            <div id="search-pagination" class="search-pagination"></div>
        </div>
    </div>

    <span class="search-close-icon">
        <i class="iconfont icon-close"></i>
    </span>
</div>
    <div id="tools">
    <div class="progressbar-top"></div>

    
        <link type="text/css" rel="stylesheet" href="/css/APlayer.css">
        <script type="text/javascript" src="/js/APlayer.min.js"></script>
        <script type="text/javascript" src="/js/Meting.min.js"></script>
        <meting-js id="3778678" lrcshow="false" server="netease" type="playlist" fixed="true" autoplay="false" loop="all" order="random" preload="auto" volume="0.67" mutex="true"></meting-js>
    
    
    <div class="wrap-right">
        <div class="setting">
            <div class="iconbox favorites" switch="false">
                <span class="iconfont icon-favorites"></span>
                <span class="icontext">关注</span>
            </div>
            <div class="iconbox mode">
                <div class="light">
                    <span class="iconfont icon-daymode"></span>
                    <span class="icontext">浅色模式</span>
                </div>
                <div class="dark">
                    <span class="iconfont icon-nightmode-fill"></span>
                    <span class="icontext">深色模式</span>
                </div>
            </div>
            <a href="javascript:;" target="_self" class="search">
                <div class="iconbox">
                    <span class="iconfont icon-search-menu"></span>
                    <span class="icontext">搜索</span>
                </div>
            </a>
            <div class="iconbox bottom">
                <div style="display: inline-block; transform: rotate(180deg);">
                    <span class="iconfont icon-top"></span>
                </div>
                <span class="icontext">跳至底部</span>
            </div>
        </div>
        <div class="iconbox set">
            <div style="display: inline-block;">
                <span class="iconfont icon-setting"></span>
            </div>
            <span class="icontext">设置</span>
        </div>
        <div class="iconbox top">
            <span class="iconfont icon-top"></span>
            <span class="icontext">返回顶部</span>
        </div>
    </div>
    <div class="loading"></div>
</div>
    <script>
    window.config = {
        GitHubUserName     : "Modena",
        GitHubRepositories : "Hexo-LiveForCode",

        User             : "Moooodena",
        UserAvatar       : "/image/sidebar/avatar.jpg",
        WebsiteStartDate : "2022-08-10",

        WebsiteTitleBlur         : "Moooodena的blog",
        WebsiteTitleBlurTimeOut  : 500,
        WebsiteTitleFocus        : "(*´∇｀*) 欢迎回来!",
        WebsiteTitleFocusTimeOut : 1000,
        WebsiteFavicon           : "/image/website/logo.png",

        ProgressBar : {
            id       : "topProgressBar",
            color    : "#77B6FF",
            height   : "2px",
            duration : 0.2
        },

        Loading: {
            rebound : {
                tension  : 16,
                friction : 5
            },
            spinner : {
                id     : "spinner",
                radius : 90,
                sides  : 3,
                depth  : 4,
                colors : {
                    background : "#F0F0F0",
                    stroke     : "#272633",
                    base       : "",
                    child      : "#272633"
                },
                alwaysForward : true,
                restAt        : 0.5,
                renderBase    : false
            }
        },

        HomeHeaderAnimationRendered : true,
        HomeHeaderAnimation         : {
            radius      : 15,
            density     : 0.2,
            color       : "rgba(255, 255, 255, .2)",
            clearOffset : 0.3
        },

        BackAnimationRendered          : true,
        IEBrowserBackAnimationRendered : false,
        BackAnimation                  : {
            colorSaturation  : "60%",
            colorBrightness  : "50%",
            colorAlpha       : 0.5,
            colorCycleSpeed  : 5,
            verticalPosition : "random",
            horizontalSpeed  : 200,
            ribbonCount      : 3,
            strokeSize       : 0,
            parallaxAmount   : -0.2,
            animateSections  : true
        },

        HomeHeaderImage : [
            
                "/image/header/home.jpg",
            
                "/image/header/home.jpeg",
            
        ],
        HomeBannerText  : "",

        ArticleHeaderImage : [
            
                "/image/header/article.jpg",
            
        ],

        OtherBannerText : "",

        Error : {
            icon    : "icon-swimming",
            title   : "PAGE NOT FOUND",
            content : [
                
                    "很抱歉，您访问的页面不存在！",
                
                    "可能是输入地址有误或该地址已变更。",
                
            ],
            buttons : [
                
                    {
                        icon  : "icon-home",
                        text  : "返回首页",
                        href  : "/",
                        class : ""
                    },
                
            ]
        },

        MenuNotice : {
            enable : true,
            notice : "简单地活着，肆意而又精彩！",
            speed  : 20
        },
        MenuList : [
            
                {
                    name   : "首页",
                    icon   : "icon-home-fill",
                    href   : "/",
                    type   : "index",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "分类",
                    icon   : "icon-folder-fill",
                    href   : "/category",
                    type   : "category",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "标签",
                    icon   : "icon-discount-fill",
                    href   : "/tag",
                    type   : "tag",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "归档",
                    icon   : "icon-calendar-fill",
                    href   : "/archive",
                    type   : "archive",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "赞赏",
                    icon   : "icon-heart-fill",
                    href   : "/donate",
                    type   : "donate",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "关于",
                    icon   : "icon-about-fill",
                    href   : "/about",
                    type   : "about",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "订阅",
                    icon   : "icon-rss",
                    href   : "/atom.xml",
                    type   : "",
                    class  : "",
                    target : "_blank"
                },
            
                {
                    name   : "搜索",
                    icon   : "icon-search-menu",
                    href   : "javascript:;",
                    type   : "",
                    class  : "search",
                    target : "_self"
                },
            
                {
                    name   : "留言板",
                    icon   : "icon-comments-fill",
                    href   : "/comment",
                    type   : "comment",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "友情链接",
                    icon   : "icon-link",
                    href   : "/friend",
                    type   : "friend",
                    class  : "",
                    target : "_self"
                },
            
        ],
        MenuLink : [
            
                
                    {
                        name   : "知乎",
                        icon   : "icon-zhihu",
                        href   : "",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
                    {
                        name   : "微博",
                        icon   : "icon-weibo",
                        href   : "",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
                    {
                        name   : "QQ",
                        icon   : "icon-qq",
                        href   : "javascript:;",
                        class  : "image",
                        target : "_self",
                        image  : "/image/sidebar/qq.png"
                    },
                
                    {
                        name   : "微信",
                        icon   : "icon-wechat",
                        href   : "javascript:;",
                        class  : "image",
                        target : "_self",
                        image  : "/image/sidebar/Wechat.png"
                    },
                
                    {
                        name   : "GitHub",
                        icon   : "icon-github",
                        href   : "https://github.com/Moooodena",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
            
        ],

        FooterStyle : 2,
        BottomText  : "<div><span class='face'>ღゝ◡╹)ノ♡</span></div><div>【人生若只如初见<span><i class='iconfont icon-like-fill'></i></span>何事秋风悲画扇】</div><div>&copy; 2020-2022 Modena. All Rights Reserved.</div>",

        ConsoleList : [
            
                
                    [
                        
                            
                                "Based on cnblogs theme SimpleMemory.",
                            
                                "",
                            
                        
                    ],
                
                    [
                        
                            
                                "SimpleMemory Author:",
                            
                                "BNDong",
                            
                        
                    ],
                
                    [
                        
                            
                                "Theme:",
                            
                                "LiveForCode",
                            
                        
                    ],
                
            
        ],

        FontIconExtend : "",

        Donate : {
            paypal  : "",
            bitcoin : "",
            alipay  : "/image/donate/alipay.png",
            wechat  : "/image/donate/wechat.png"
        },

        Search : {
            applicationID : "010C3EANT8",
            apiKey        : "c7abab9f11b79102b9aff7fe6d41447d",
            indexName     : "Notes",
            hits          : {
                page : 10
            },
            labels        : {
                placeholder : "搜索",
                empty       : "未发现与 「${query}」 相关的内容",
                stats       : "${hits} 条相关条目，使用了 ${time} 毫秒",
            }
        }, 

        Valine : {
            switch         : true,
            el             : ".comments-content",
            appId          : "srhKtvWPQTWYKh3qX8G8M7v0-gzGzoHsz",
            appKey         : "8uVSP1q6UlALVC5igYfIfv2h",
            serverURLs     : "",
            placeholder    : "你是我一生只会遇见一次的惊喜...",
            avatar         : "mm",
            meta           : "nick,mail,link",
            requiredFields : "nick,mail",
            pageSize       : 5,
            lang           : "zh-cn",
            visitor        : true,
            enableQQ       : true
        },

        Tocbot : {
            switch                : true,
            tocSelector           : ".toc",
            contentSelector       : ".article-body",
            headingSelector       : "h1, h2, h3, h4, h5",
            headingsOffset        : 0,
            scrollSmooth          : true,
            scrollSmoothOffset    : -5,
            positionFixedSelector : ".toc",
            positionFixedClass    : "toc-fixed",
            fixedSidebarOffset    : "",
        },

        Require : {
            baseUrl     : "/js/",
            waitSeconds : 100
        },

        Music : {
            type : "Meting"
        },
        APlayer : {
            container : ".aplayer",
            fixed     : true,
            autoplay  : false,
            loop      : "all",
            order     : "random",
            preload   : "auto",
            volume    : 0.67,
            mutex     : true,
            lrcType   : 3,
            audio     : [
                
                    {
                        name   : "Endless Tears",
                        artist : "CLIFF EDGE",
                        cover  : "/music/cover/Endless Tears.jpg",
                        url    : "/music/song/Endless Tears.mp3",
                        lrc    : "/music/lrc/Endless Tears.lrc"
                    },
                
            ]
        },
        Meting : {
            id       : "3778678", 
            lrcshow  : false, 
            server   : "netease", 
            type     : "playlist", 
            fixed    : true, 
            autoplay : false, 
            loop     : "all", 
            order    : "random", 
            preload  : "auto", 
            volume   : 0.67, 
            mutex    : true
        },

        Mouse : {
            enable  : true,
            options : {
                size  : 6,
                sizeF : 24
            }
        },

        LazyLoad : {
            default : "/image/website/lazyload.svg"
        },
  
        Style : {
            aplayer          : "/css/APlayer.css",
            archive          : "/css/archive.css",
            base             : "/css/base.css",
            clipboard        : "/css/clipboard.css",
            code             : "/css/code.css",
            donate           : "/css/donate.css",
            fancybox         : "/css/jquery.fancybox.css",
            footer           : "/css/footer.css",
            iconfont         : "/iconfont/iconfont.css",
            index            : "/css/index.css",
            menuBubble       : "/css/menu-bubble.css",
            mouse            : "/css/mouse.css",
            page             : "/css/page.css",
            post             : "/css/post.css",
            search           : "/css/search.css",
            tocbot           : "/css/tocbot.css",
            valine           : "/css/valine.css"
        },

        Script: {
            aplayer          : "/js/APlayer.min.js",
            config           : "/js/require.config.js",
            index            : "/js/index.js",
            instantSearch    : "/js/instantsearch.min.js",
            iscroll          : "/js/iscroll.js",
            jQuery           : "/js/jquery-3.4.1.min.js",
            loading          : "/js/loading.js",
            meting           : "/js/Meting.min.js",
            require          : "/js/require.min.js"
        },

        Font: {
            LongCang    : "/font/LongCang.css",
            Monda       : "/font/Monda.css",
            NotoSansSC  : "/font/NotoSansSC.css",
            NotoSerifSC : "/font/NotoSerifSC.css",
            Playball    : "/font/Playball.css",
            PTMono      : "/font/PTMono.css",
            Roboto      : "/font/Roboto.css",
            RobotoSlab  : "/font/RobotoSlab.css",
            Rosario     : "/font/Rosario.css",
            UbuntuMono  : "/font/UbuntuMono.css"
        },

        Suffix : {
            about : "简单地活着, 肆意又精彩."
        },
            
        Theme : {
            url  : "https://github.com/first19326/Hexo-LiveForCode",
            name : "Hexo - Live For Code"
        }  
    };
</script>
    <script type="text/javascript" src="/js/index.js"></script>
</body>
</html>